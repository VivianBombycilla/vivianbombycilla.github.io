---
id: 37
date: 2025-12-01
title: "Advent of Code 2025: C++"
category: fun
subtitle: "Day 00: Getting Started"
post-series: aoc
num-in-series:
published: true
---
Last year was my first year successfully getting all stars in Advent of Code, and I did so in Python. This year I want to do it in C++, which is a language I have essentially zero experience in. Should be fun!

### Getting Started

To begin with, [Learn C++](https://www.learncpp.com/) looks like a helpful tool to get started, so I followed the introductory Chapter 0 a while ago to get set up.  I followed [this tutorial](https://code.visualstudio.com/docs/cpp/config-mingw) to be able to use the GCC C++ compiler in VS Code, skimmed Chapter 1 (the biggest thing I didn't know was the differences between the different variable initialization styles), and then went straight to [Chapter 28.6](https://www.learncpp.com/cpp-tutorial/basic-file-io/) to get started with file I/O (since I'm going to have to read inputs from a file).

Now, right away, I ran into an issue. When I clicked the button in VS Code to run and debug my program, the output (and input) files were found in the folder containing `g++.exe`, that is, `C:\msys64\ucrt64\bin`, instead of my working directory which is where I'd rather they go. So, what's up with that? Figuring this out meant understanding a bit more about how VS Code works, but I figured it out: When I click the "play" button and select `g++.exe` as my compiler, this compiles my `.exe` file from my `.cpp` file, and saves the settings as a task in `tasks.json`. Then, it also *runs* this `.exe` file, but the working directory never gets updated from that one containing `g++.exe`.

If I instead click the settings cog first, "Add Debug Configuration", and select `g++.exe` from there, VS Code creates not only the appropriate `tasks.json` file, but also `launch.json`, which contains a configuration for running and debugging the code. Within this configuration, the parameter `cwd` is set to `"C:\\msys64\\ucrt64\\bin"`, that is, the folder containing `g++.exe`, but if I change this instead to `${fileDirname}` the program will instead run my `.exe` from the directory of the `.exe` file itself. Thus, I can use file I/O with relative paths, and the program will behave much more as expected, and the source code will be more portable as well.