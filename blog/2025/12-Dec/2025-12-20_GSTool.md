---
id: 51
date: 2025-12-20
title: Developing a Graphical Standings Tool
category: fun
subtitle: "Part 7: Adding arbitrary CSS classes to my SVG elements"
post-series: gstool
published: true
---
One thing missing from my tools so far is adding arbitrary classes (for CSS selecting) to my elements. This is something pretty fundamental so I'm considering now where to put it in my code. Perhaps my `Element` class?

Here's how CSS classes in SVG elements work: They're stored in the `class` attribute, and multiple CSS classes in one element are separated by a single space. What I'm going to want to do is have a way to manipulate the CSS classes in an element. I'm thinking of adding a `classes` attribute to the `Element` class, which can be updated and manipulated (using some kind of access functions), and which updates its corresponding XML attribute `class`.

So, my first question is, what should the data type of `Element.classes` be? I think `set` would be quite appropriate, since all that matters is membership, and the [order of CSS classes within the XML element does not matter](https://stackoverflow.com/questions/1321692/how-to-specify-the-order-of-css-classes) (only the order of the class selectors on the stylesheet!). On the other hand, if I use `set`, then my program becomes non-deterministic: The order in which the classes appear in the XML element may change from time to time. What I'd really like is an ordered set like in C++, but [that doesn't seem to exist yet](https://stackoverflow.com/questions/1653970/does-python-have-an-ordered-set/53657523#53657523).

I think I'll go with `set` as my data type. Now, my next question: Can I make it so that whenever `self.classes` is updated, the program also runs `self.set("classes", " ".join(self.classes))`? I wonder if the `@property` decorator is what I'm looking for right now. Is this something I even want?

[This article](https://www.freecodecamp.org/news/python-property-decorator/) on freeCodeCamp was very helpful for learning how the `@property` decorator works.

### Implementation complications
I went all gung-ho and implemented the system for the `.classes` attribute with the `@property` decorator, which is actually super fun! 
  

	class Element(ET.Element):
	
	    def __init__(
	        self,
	        tag: str,
	        attrib: dict[str, str] = {},
	        text: str | None = None,
	        classes: set[str] = set(),
	        **extra: str,
	    ) -> None:
	        super().__init__(tag, attrib, **extra)
	        self.text = text
	        self.classes = classes
	        
	    @property
	    def classes(self) -> set[str]:
	        return self._classes
	        
	    @classes.setter
	    def classes(self, new_classes: set[str]) -> None:
	        self._classes = new_classes
	        if self._classes:
	            self.set("class", " ".join(self._classes))

I've just got one issue: What if I don't want to use this attribute in the initialization? What if `self.attrib["classes"]` is set?

So indeed, I need to add an extra few lines of code, in between `self.text = text` and `self.classes = classes`:

	        # Get classes
	        class_attrib = self.get("class")
	        # If we found any classes, update our current set of classes
	        if class_attrib is not None:
	            classes.update(class_attrib.split(" "))

Thus we can easily add arbitrary classes to our SVG elements. I could also pretty easily write a function to toggle chosen classes on and off. Cool!