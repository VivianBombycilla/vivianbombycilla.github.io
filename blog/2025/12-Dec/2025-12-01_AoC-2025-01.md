---
id: 39
date: 2025-12-01
title: "Advent of Code 2025: C++"
category: fun
subtitle: "Day 01: Secret Entrance"
post-series: aoc
published: false
---
Today was pretty straightforward conceptually, as is usually the case for Day 01, which I found quite nice to get used to coding in C++.

The structure of the program I've written is pretty simple: I wrote a function to parse the instructions and output the result. Then, reading lines sequentially from a file, I simulate following the instructions one by one, keeping track of the two statistics we need as answers to Part 1 and Part 2.

### Reading from a file
To read from a file I set up an `std::ifstream` object to read from `day01.txt`. Then, I use `std::getline` to read from the stream line by line. At the end of the `main()` function, the stream is closed automatically.

When initializing a `stf::ifstream` variable, if the program is unsuccessful at reading from the specified file, it fails quietly, that is, the variable doesn't get initialized and the program keeps running. Thus, we also check to see whether the variable is initialized, and if not, throw an error. 

    // Read input file
    std::ifstream inf {"day01.txt"};

    // If we couldn't open the input file stream for reading
    if (!inf)
    {
        // Print an error and exit
        std::cerr << "Uh oh, the file could not be opened for reading!\n";
        return 1;
    }
	
	// Read from input stream line by line
    std::string strInput {};
    while (std::getline(inf, strInput))
    {
        // Main loop
    }

### The main loop (first draft)
In the main loop, I keep track of variables `int dialPosition{50}`, `int part1{0}`, and `int part2{0}`, while using the temporary helper variable `int rawNewDialPosition`. I didn't know how to use tuples (or whether I should be using tuples or something else) so I didn't. On each loop iteration I do the following:
- Read the next line of the input stream and store it in `strInput`.
- Parse the instruction and return the new dial position using `runInstruction()`, before the modulo, stored in `rawNewDialPosition`.
- Compute how many times the dial pointed at zero when performing the instruction (for Part 2). This is done using `zeroPoints()` and the output is added to `part2`.
- Compute the new dial position (taking the positive remainder) and store it in `dialPosition`.
- Check if the new `dialPosition == 0`, if so, increment `part1`.
### A second draft
To make this program simpler, for my second draft I defined a `DialState` class to store the state of the dial, as well as counters to keep track of the running totals for Part 1 and Part 2. Then, I redefined the `runInstruction` function to be a void function taking a reference to a `DialState` object as well as the instruction, and updates the corresponding `dialPosition`, `part1`, and `part2` parameters.

My source code can be found [here](https://github.com/VivianBombycilla/aoc2025/tree/main/code).
