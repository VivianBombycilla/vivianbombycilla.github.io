---
id: 43
date: 2025-12-05
title: "Advent of Code 2025: C++"
category: fun
subtitle: "Day 05: Cafeteria"
post-series: aoc
published: true
---
Today one of my biggest challenges was parsing the input, since this was the first day in which the input switched from one style to another midway through. I managed to do it with the help of `std::istringstream`, which I can use to read strings into `uint64_t` conveniently.

### Part 1
For part 1, parsing the input was pretty much the whole battle. I then just had to write a function to check if a number was in a range, and then run through the input. One new thing I learned today was `std::pair`, and especially the `.first` and `.second` parameters of this class which are easier to use than `std::get` is on other `std::tuple` objects.

### Part 2
My algorithm was pretty straightforward today as well: I kept a set of ranges, `optimizedRanges`, which are already optimized, as well as a vector of ranges `freshRanges` which I want to add to my set. At each step, I see if the next range, `range1` in `freshRanges` intersects any range `range2` from `optimizedRanges`. If so, I remove `range1` from `freshRanges`, `range2` from `optimizedRanges`, merge `range1` and `range2` (into, say, `range3`), and then finally add this new range (`range3`) back into `freshRanges`.

This process can run until `freshRanges` is empty. Then, we can easily count how many fresh ingredients there are in total.

### Possible improvements
My Part 2 could be faster if we sorted the ranges first, by either largest or smallest fresh ingredient, because then checking whether a range intersects with any in our optimized list would be faster (since we'd actually only have to check one pair of ranges, rather than all of them!). On the other hand, maybe I'm already doing that, since `std::set` is already sorted. If I am, I should find out! I don't think I am though since `freshRanges` is just a vector.