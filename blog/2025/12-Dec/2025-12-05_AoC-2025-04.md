---
id: 42
date: 2025-12-05
title: "Advent of Code 2025: C++"
category: fun
subtitle: "Day 04: Printing Department"
post-series: aoc
published: true
---
I got my wish for a more difficult day! It's the first grid puzzle of the year. There was still room to get away with not doing anything smart, which is convenient because I'm a day behind! I'm definitely gonna come back and do something better.

### Part 1
To begin with, I store the grid in a variable, of type `std::vector<std::string>`. This is my first time using `std::vector`, but it's pretty intuitive at a high level, and I've not thought about the implementation too deeply, so to me it looks somewhat like a Python `list` which must be of one type only.

The grid is stored as a parameter `grid` in my own class, `RollGrid`, which I give a function to set its own parameters `rows` and `cols` based on itself. I then define a function `isRoll` within the class to find if a location (specified by `row` and `col`) is a roll (while returning `false` if the location is out of range). Thus, one last function `countAdjacentRolls` counts the rolls adjacent to a specified location on the grid.

Finally, we can loop through the grid, one at a time, to count how many rolls have less than 4 adjacent rolls.

### Part 2
Here's the part for which my solution can be vastly improved. To do this part I basically run Part 1 over and over again: I edited my Part 1 solution to output a `std::set` of locations, which I can then count, and then use to edit the board (since strings are mutable in C++). Thus I can run this function over and over again to get the Part 2 answer.

### Possible improvements
This solution is very inefficient because I run through the entire board every time, and count every adjacent roll every time as well, both things that can be optimized away. I'll do this another time, because I need to get on with Day 05 and more! If I do come back to this I'll add a note here.