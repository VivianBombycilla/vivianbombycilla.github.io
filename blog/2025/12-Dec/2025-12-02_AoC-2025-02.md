---
id: 40
date: 2025-12-02
title: "Advent of Code 2025: C++"
category: fun
post-series: aoc
subtitle: "Day 02: Gift Shop"
---
Today's problem was pretty interesting and fun! I had to get to know more C++ types, and came up against the standard library being rather more minimal than that of Python. Coming out the other end, I'm quite excited about having to think about types a lot more, because I feel like it improves my coding. My initial drafts used `std::stoi`, but I ended up discarding this in favour of working solely with `uint64_t`. The result is a solution that I wouldn't have felt pressured into writing if I was coding in Python, because manipulating strings and converting between types is so easy.

### Part 1
In order to find invalid IDs between specified `uint64_t first` and `uint64_t last` (inclusive), I decided to calculate the least invalid ID which was `>= first`, and the greatest invalid ID which was `<= last`. 

To do this, I wrote a function `findAdjacentInvalidID` taking parameters `uint64_t id` and `bool prev` (indicating whether to find `<=` or `>=`). This function outputs an integer pre-reduplication.
- First, check if `id` has an even number of digits. I implemented this as `numDigits`.
- **If so:**
	- Take the first half of the digits of `id` and store it in `firstHalf`, and compute the associated invalid ID `firstHalfID`.
	- Comparing `firstHalfID` with `id`, and considering `prev`, then `firstHalf` may be off by one. Fix it!
- **If not:**
	- Then the previous and next invalid ID are easy to come up with, simply being the greatest invalid ID of smaller length, and the least invalid ID of a greater length.

From there it's easy to find all the invalid IDs between `first` and `last`, and all them all up.
### Part 2
With the expanded criteria for invalidity of an ID, my code can thankfully be adjusted by adding another parameter, `int times`. Then for each pair `first`, `last` it suffices to check each value of `times` and add the invalid IDs found. There's one more complication which is that it's possible an invalid ID gets flagged for multiple values of `times`. Thus, we store the invalid IDs found on each call of `findInvalidIDs` in a set, `std::set<uint64_t>`, so that we do not double-count.


